<!DOCTYPE html>
<html>

<head>
  <link rel="icon"
    href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸŽ¯</text></svg>">
</head>

<body>
  <div id="app">
    <div>
      <img src="doggie.jpeg" class="main-image" width="320" height="480">
      <canvas onclick="getClick(event)" id="canv" width="320px" height="480px"></canvas>
    </div>
  </div>

  <script>
    //Grab the data from a new image
    let img = new Image();
    img.src = "./doggie.jpeg";
    img.onload = () => {
      main();
    };
    img.onerror = () => {
      document.body.appendChild(new Text("Could not load the image."));
    };

    // let currentClick;
    let interval;
    let settingMask = false;

    class RGB {
      constructor(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
      }
    };
    class Point {
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }
    }

    let cursor_x = -1;
    let cursor_y = -1;
    document.onmousemove = function (event) {
      cursor_x = event.offsetX;
      cursor_y = event.offsetY;
    }

    let layer = { upperLeft:Point, lowerRight:Point };


    //Called once we have image data
    function main() {

      //Get the context of the canvas
      ctxStart = document.getElementById("canv").getContext("2d");

      //Draw the original image to the canvas
      ctxStart.drawImage(img, 0, 0, 320, 480);

      //Get the pixels of the canvas
      canvasPixels = ctxStart.getImageData(0, 0, ctxStart.canvas.width, ctxStart.canvas.height)

      mirrorImage();
    }

    function mirrorImage() {
      let pixels = [];
      for (let y = 0; y < ctxStart.canvas.height; y++) {
        for (let x = 0; x < ctxStart.canvas.width; x++) {
          //The data is linear, get the x,y coordinate
          //We mulitply by 4 since it is stored as rgba
          let pixelIndex = ctxStart.canvas.width * 4 * y + x * 4;

          //Convert to grayscale on half the image
          if (x < ctxStart.canvas.width / 2) {
            let r = canvasPixels.data[pixelIndex];
            let g = canvasPixels.data[pixelIndex + 1];
            let b = canvasPixels.data[pixelIndex + 2];

            pixels.push(new RGB(r, g, b));
            //Trivial grayscale conversion using the red channel
            // g = r;
            // b = r;

            // //Update the pixel data
            // canvasPixels.data[pixelIndex] = r;
            // canvasPixels.data[pixelIndex + 1] = g;
            // canvasPixels.data[pixelIndex + 2] = b;
          }
          else {
            let pixel = pixels.pop();
            canvasPixels.data[pixelIndex] = pixel.r;
            canvasPixels.data[pixelIndex + 1] = pixel.g;
            canvasPixels.data[pixelIndex + 2] = pixel.b;
          }
        }
      }

      //Set the pixel data
      ctxStart.putImageData(canvasPixels, 0, 0);
    }

    function getClick(event) {
      console.log(event.offsetX + ":" + event.offsetY);
      if (settingMask) {
        clearInterval(interval);
      } else {
        layer.upperLeft = new Point(event.offsetX, event.offsetY);
        interval = setInterval(updateRect, 100);
      }
      settingMask = !settingMask;
    }

    function updateRect() {
      clear();
      ctxStart.strokeStyle = "red";

      let lrx = cursor_x - layer.upperLeft.x;
      let lry = cursor_y - layer.upperLeft.y;

      ctxStart.strokeRect(layer.upperLeft.x, layer.upperLeft.y, lrx, lry);
      layer.lowerRight.x = lrx;
      layer.lowerRight.y = lry;
    }

    function clear() {
      ctxStart.clearRect(0, 0, 320, 480);
      mirrorImage();
    }
  </script>

</body>

</html>